import{_ as a,r as o,o as r,c as n,a as e,d as c,b as s,e as h}from"./app-c93fxKWf.js";const i={},l=h('<h1 id="網頁緩存機制-web-cache" tabindex="-1"><a class="header-anchor" href="#網頁緩存機制-web-cache" aria-hidden="true">#</a> 網頁緩存機制 Web Cache</h1><p>Web 緩存分為兩種:<strong>瀏覽器緩存</strong>和<strong>http 緩存</strong>。</p><h2 id="瀏覽器緩存" tabindex="-1"><a class="header-anchor" href="#瀏覽器緩存" aria-hidden="true">#</a> 瀏覽器緩存</h2><p>資料儲存本地的瀏覽器，像是「像 localStorage，sessionStorage 这种用户缓存数据的功能，他只能保存 5M 左右的数据，多了不行。cookie 则更少，大概只能有 4kb 的数据」</p><h2 id="http-緩存" tabindex="-1"><a class="header-anchor" href="#http-緩存" aria-hidden="true">#</a> http 緩存</h2><p>web 緩存最重要的是理解 http 緩存，在執行上細分為<strong>強緩存</strong>和<strong>協商緩存</strong>。</p><ul><li><strong>強緩存</strong>是利用 http head 部分的 Cache-control 屬性，透過定義資源要緩存多久。比如:&#39;Cache-Control&#39;:&#39;max-age=10&#39;，即這資源在 10 秒內如果再次請求，就會從緩存中讀取。</li></ul><blockquote><p>Cache-control 的配置選項 max-age 決定客户端資源被缓存多久 s-maxage 決定代理服务器缓存的時間 no-cache 表示是强制進行協商缓存 no-store 是表示禁止任何缓存策略 public 表示資源即可以被瀏覽器缓存也可以被代理服務器缓存 private 表示資源只能被瀏覽器缓存</p></blockquote><ul><li><strong>協商緩存</strong>是利用 http head 部分的 last-modified 屬性，註記資源最後修改時間，並關閉強緩存(Cache-control:no-cache)下，讓客戶端下次請求資源時，head 中會新增 If-Modified-Since 屬性，帶上上次服務器回傳 last-modified 時間，讓服務端可以比對，最後決定回傳資源沒有被修改(304)，還是回傳新的資源，並在 last-modified 註記新的最後修改時間</li></ul><blockquote><p>上面這種比對時間的方式，可能衍伸了資源(是文件黨)被修改時間的問題，會導致比對沒有真正判斷資源有沒有被修改。因此有了新的「Etag」，只是把 ast-modified 屬性的最後修改時間換成了生成 ETag(依據內容生成的 hash 值)</p></blockquote><hr>',11),d={href:"https://juejin.cn/post/7127194919235485733",target:"_blank",rel:"noopener noreferrer"};function p(g,u){const t=o("ExternalLinkIcon");return r(),n("div",null,[l,e("p",null,[e("a",d,[c("稀土掘金-中高级前端工程师都需要熟悉的技能--前端缓存"),s(t)])])])}const b=a(i,[["render",p],["__file","webCache.html.vue"]]);export{b as default};
