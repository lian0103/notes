import{_ as r,r as c,o as i,c as l,a as e,d as t,b as n,e as o}from"./app-92RcE6eu.js";const s={},p=o('<h1 id="瞭解-webpack、vite-的發展脈絡" tabindex="-1"><a class="header-anchor" href="#瞭解-webpack、vite-的發展脈絡" aria-hidden="true">#</a> 瞭解 webpack、Vite 的發展脈絡</h1><h2 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> webpack</h2><p>webpack 發展的背景，是由於前端開發領域重視使用模組化標準(commonJS、ECMAScript6(簡稱 ES6))、框架開發應用(vue、react)和新語法導入(ES6、TypeScript、SCSS)，在瀏覽器不能直接解析這些內容的情況下，需要建構工具來編譯成瀏覽器可使用的檔案(ES5、css、html)。</p><p>而 webpack 相較於同時期的建構工具(Grunt、Ｇ ulp、Fis3、Rollup)更為流行，是因為 webpack 有著更完整的建構模組的機制，它把一切相依的資源透過遞迴編譯為模組，並搭配載入(loader)和掛載(plugin)的配置使用，讓切分出的模組資源能依情境需求再分割為更小單位的代碼模塊(chunk)。</p><p>但隨著專案規模的擴大，開發過程會更明顯感受到透過遞迴每一個倚賴的建構時間變長。</p><h2 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> vite</h2><p>現階段 vite 的崛起，它著手解決 webpack 的一些缺點。</p><p>當瀏覽器採用 ES 模組標準後，在瀏覽器可以直接使用當初不被支援的語法，那相對的 webpack 最初的使用理由之一，將新語法編譯成 ES5 的需求就不再存續，vite 也因為這個新支援的特性，來取代 webpack 的建構機制，特性包含依需求載入當前的倚賴和透過 http 緩存加強的 HMR(熱模塊更新)模式;且結合 rollup 編譯的輸出結果上也有了優化，包含刪除無用倒的代碼(tree-shaking)、懒加载和 chunk 分割。</p><p>2022 年 7 月剛發布 vite v3 版本，開始導入 esbuild 來優化建構 css。</p><h2 id="資料來源" tabindex="-1"><a class="header-anchor" href="#資料來源" aria-hidden="true">#</a> 資料來源</h2>',10),h=e("li",null,[e("p",null,[t("JS 高手昇華之路:Webpack 是唯一途徑(2018 年 6 月 出版）"),e("br"),e("img",{class:"imgInMd",src:"https://i.imgur.com/dSYvf5A.jpg",alt:"html5"})])],-1),d=e("br",null,null,-1),u={href:"https://cn.vitejs.dev/guide/why.html",target:"_blank",rel:"noopener noreferrer"},_=e("br",null,null,-1),b={href:"https://v2.vitejs.dev/guide/why.html",target:"_blank",rel:"noopener noreferrer"};function k(v,m){const a=c("ExternalLinkIcon");return i(),l("div",null,[p,e("ol",null,[h,e("li",null,[e("p",null,[t("vite v2、v3 官方文檔"),d,e("a",u,[t("v3 文檔"),n(a)]),t(),_,e("a",b,[t("v2 文檔"),n(a)])])])])])}const w=r(s,[["render",k],["__file","webpackAndVite.html.vue"]]);export{w as default};
